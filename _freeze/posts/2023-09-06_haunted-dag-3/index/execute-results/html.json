{
  "hash": "c7b247df67315c8a2f07066c54df508e",
  "result": {
    "markdown": "---\ntitle: \"Colliders\"\norder: 17\ndate: 2023-09-06\ntwitter-card: true\nopen-graph: true\n---\n\n\n::: callout-note\n## Listening\n\n<iframe style=\"border-radius:12px\" src=\"https://open.spotify.com/embed/track/2TWlMqgTSmfz8v2F4ONWzn?utm_source=generator\" width=\"100%\" height=\"152\" frameBorder=\"0\" allowfullscreen allow=\"autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture\" loading=\"lazy\">\n\n</iframe>\n:::\n\n## Setup\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(tidyverse)\nlibrary(tidybayes)\nlibrary(brms)\nlibrary(gt)\nlibrary(gtsummary)\nlibrary(patchwork)\nlibrary(ggblend)\nlibrary(ggdensity)\nlibrary(ggforce)\nlibrary(marginaleffects)\nlibrary(dagitty)\nlibrary(ggdag)\n\n\nsource(here::here(\"_defaults.r\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2023-9-6)\n```\n:::\n\n\n## Collider Bias\n\nWhen A has an effect on Z, and B has an effect on Z, then Z is a \"collider\" variable between A and B.\n\n\n```{mermaid}\ngraph LR\n  a[\"A\"]\n  b[\"B\"]\n  z[\"Z\"]\n  \n  a --> z\n  b --> z\n```\n\n\nSo, if I understand things right, fitting a model with\n\n```         \nA ~ B\n```\n\nwould result in no effect of B on A, which we can check with a DAG.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndagify(\n  Z ~ A,\n  Z ~ B\n) |> \n  impliedConditionalIndependencies()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA _||_ B\n```\n:::\n:::\n\n\n*But*, if we fit a model with\n\n```         \nA ~ B + Z\n```\n\n*now* there would suddenly seem to be an effect of B on A. As a simple demo, we can repeat the [simulation of newsworthiness and trustworthiness](../2023-09-01_14-haunted-dag/index.qmd).\n\n\n::: {.cell filename='simulating selection'}\n\n```{.r .cell-code}\ntibble(\n  trustworthiness = rnorm(200),\n  newsworthiness = rnorm(200),\n  score = trustworthiness + newsworthiness,\n  score_percentile = ecdf(score)(score),\n  selected = score_percentile >= 0.9\n) ->\n  research\n```\n:::\n\n::: {.cell crop='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\nresearch |> \n  ggplot(\n    aes(\n      newsworthiness,\n      trustworthiness,\n      color = selected\n    )\n  ) +\n    geom_point()+\n    theme(\n      aspect.ratio = NULL\n    )+\n    coord_fixed()\n```\n\n::: {.cell-output-display}\n![Selection bias](index_files/figure-html/fig-selection-1.png){#fig-selection width=576}\n:::\n:::\n\n\nLast time we just fit a model using the subset of selected values. But here it goes modelling with the whole dataset. First, without the collider.\n\n\n::: {.cell filename='no collider model'}\n\n```{.r .cell-code}\nbrm(\n  trustworthiness ~ newsworthiness,\n  data = research,\n  backend = 'cmdstanr',\n  file = \"research1\"\n)->\n  research1_mod\n```\n:::\n\n\nThen, with the collider.\n\n\n::: {.cell filename='collider model'}\n\n```{.r .cell-code}\nbrm(\n  trustworthiness ~ newsworthiness + selected,\n  data = research,\n  backend = 'cmdstanr',\n  file = \"research2\"\n)->\n  research2_mod\n```\n:::\n\n::: {.cell filename='getting parameters'}\n\n```{.r .cell-code}\nlist(\n  `no collider` = research1_mod,\n  collider = research2_mod\n) |> \n  map(\n    ~.x |> \n      gather_draws(\n        `b_.*`,\n        regex = T\n      )\n  ) |> \n  list_rbind(\n    names_to = \"model\"\n  )->\n  collide_comp\n```\n:::\n\n\nJust focusing on the intercept and newsworthiness effects, they went from (correctly) being unrelated in the model without the collider, to having pretty reliable effects by just including the `selected` variable.\n\n\n::: {.cell crop='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\ncollide_comp |> \n  filter(\n    str_detect(\n      .variable,\n      \"selected\",\n      negate = T\n    )\n  ) |> \n  ggplot(\n    aes(\n      .value,\n      .variable,\n      color = model\n    )\n  ) +\n    geom_vline(xintercept = 0) +\n    stat_pointinterval(\n      position = position_dodge(width = 0.2)\n    )+\n    theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![Comparing estimates from models with and without the collider](index_files/figure-html/fig-collide-comp-1.png){#fig-collide-comp width=80%}\n:::\n:::\n\n\n## Haunting!\n\nHere's the scary part. The illustration from the book is about inter-generational effects on education. Grandparents will have an effect on their children (the parent) and parents will have an effect on their children. The question is, is there any direct effect of grandparents on children.\n\n\n```{mermaid}\ngraph LR\n  g[Grandparent]\n  p[Parent]\n  c[Child]\n  \n  g --> p\n  g -.->|?| c\n  p --> c\n```\n\n::: {.cell filename='finding the direct effect'}\n\n```{.r .cell-code}\ndagify(\n  p ~ g,\n  c ~ p,\n  c ~ g\n) |> \n  adjustmentSets(\n    exposure = \"g\", \n    outcome = \"c\",\n    effect = \"direct\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{ p }\n```\n:::\n:::\n\n\nOk, but the *spooky* thing is what if there's a variable (like, neighborhood) that's shared by the parent and child, but not the grandparent, which we didn't record.\n\n\n```{mermaid}\ngraph LR\n  g[Grandparent]\n  p[Parent]\n  c[Child]\n  n[Neighborhood]\n  \n  g -.->|?| c\n  g --> p\n  p --> c\n  n --> p\n  n --> c\n  \n  style n stroke-dasharray: 5 5\n```\n\n\nParent has apparently become a collider, but I'm still trying to noodle through why.\n\n------------------------------------------------------------------------\n\nOk, having stepped away for a bit, I think my problem was some confusion about how the \"paths\" work in DAGs.\n\n::: callout-important\n## I realized:\n\n-   The connections from one node to another are directed.\n\n-   **But** when charting a path from a variable to the outcome, you *ignore* the directedness.\n\n-   *Then*, you add back in the directedness to diagnose confounder, mediator, collider etc.\n:::\n\nSo, ignoring the directedness, we have the following paths from Grandparent to Child.\n\n::: {.callout-note icon=\"false\"}\n## Undirected Paths\n\n1.  Grandparent --- Child\n2.  Grandparent --- Parent --- Child\n3.  Grandparent --- Parent --- Neighborhood --- Child\n:::\n\nThen, we can add in the directedness\n\n::: {.callout-note icon=\"false\"}\n## Directed Paths\n\n1.  Grandparent → Child\n2.  Grandparent → Parent → Child\n3.  Grandparent → Parent ← Neighborhood → Child\n:::\n\nBecause of path 2, (Grandparent → Parent → Child), in order to get the \"direct effect\" of Grandparent, we need to include Parent. But because of path 3 (Grandparent → Parent ← Neighborhood → Child), Parent is also a Collider. If we don't include Neighborhood in the model (maybe because we didn't measure it!) the estimate for Grandparent is going to get all screwy!\n\nI'm still developing my intuitions for *why* and *how* the estimate will get screwy.\n\n::: {.callout-note collapse=\"true\"}\n## Getting the paths\n\nWith `{dagitty}` and `{ggdag}` you're supposed to be able to get the paths automatically, but I can't get the `{ggdag}` one to work give me the collider path.\n\n\n::: {.cell filename='making the dag'}\n\n```{.r .cell-code}\ndagify(\n  c ~ g + p + n,\n  p ~ g + n\n) ->\n  haunted_dag\n```\n:::\n\n::: {.cell filename='with dagitty'}\n\n```{.r .cell-code}\nhaunted_dag |> \n  paths(\n    from = \"g\",\n    to = \"c\"\n  ) |> \n  pluck(\"paths\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"g -> c\"           \"g -> p -> c\"      \"g -> p <- n -> c\"\n```\n:::\n:::\n\n::: {.cell filename='with ggdag'}\n\n```{.r .cell-code}\nhaunted_dag |> \n  ggdag_paths(\n    from = \"g\",\n    to = \"c\",\n    directed = F\n  )+\n    theme_dag()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=576}\n:::\n:::\n\n\nI think `ggdag::ggdag_paths()` is calling `dagitty::paths()` underneath, and just isn't passing the `directed` argument correctly as of\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.Date()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-09-06\"\n```\n:::\n:::\n\n\nI *can* get it to plot colliders, though.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhaunted_dag |> \n  ggdag_collider()+\n  theme_dag()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=576}\n:::\n:::\n\n:::\n\n### Simulating the haunted dag\n\nI'll mostly just copy the simulation parameters from the book.\n\n\n::: {.cell filename='setting the direct effects'}\n\n```{.r .cell-code}\n# Grandparent on parent\nb_GP <- 1\n\n# Parent on Child\nb_PC <- b_GP\n\n# Grandparent on Child\nb_GC <- 0\n\n# neighborhood\nb_N <- 2\n```\n:::\n\n::: {.cell filename='The simulation'}\n\n```{.r .cell-code}\nn = 200\n\ntibble(\n  grandparent = rnorm(n),\n  neighborhood = rbinom(\n    n, \n    size = 1, \n    prob = 0.5\n  ),\n  parent = rnorm(\n    n,\n    mean = b_GP * grandparent + \n           b_N * neighborhood\n  ),\n  child = rnorm(\n    n,\n    mean = b_GC * grandparent +\n           b_PC * parent + \n           b_N  * neighborhood\n  )\n) ->\n  haunted_sim\n```\n:::\n\n::: {.cell crop='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\nhaunted_sim |> \n  ggplot(\n    aes(\n      grandparent,\n      child,\n      color = factor(neighborhood)\n    )\n  )+\n  geom_point()+\n  guides(\n    color = \"none\"\n  )+\n  theme(\n    aspect.ratio = 0.8\n  )->\n  gc_plot\n\nhaunted_sim |> \n  ggplot(\n    aes(\n      parent,\n      child,\n      color = factor(neighborhood)\n    )\n  )+\n    geom_point()+\n  theme_blank_y()+\n  guides(\n    color = \"none\"\n  )+  \n  theme(\n    aspect.ratio = 0.8\n  )->  \n  pc_plot\n\nhaunted_sim |> \n  ggplot(\n    aes(\n      factor(neighborhood),\n      child,\n      fill = factor(neighborhood),\n      color = factor(neighborhood)\n    )\n  )+\n    geom_dots(\n      dotsize = 1.3,\n      layout = \"hex\",\n      side = \"both\"\n    )+\n  labs(x = \"neighborhood\")+\n  theme_blank_y()+\n  guides(\n    color = \"none\",\n    fill = \"none\"\n  )+  \n  theme(\n    aspect.ratio = 0.8\n  )->\n  nc_plot\n\ngc_plot + pc_plot + nc_plot\n```\n\n::: {.cell-output-display}\n![Simulated 'haunted' data](index_files/figure-html/fig-haunted-sim-1.png){#fig-haunted-sim width=576}\n:::\n:::\n\n\nNow, let's fit the model with just grandparent and parent (because, in this example, we don't know about the neighborhood).\n\n\n::: {.cell filename='the haunted collider model'}\n\n```{.r .cell-code}\nbrm(\n  child ~ parent + grandparent,\n  data = haunted_sim,\n  prior = c(\n    prior(normal(0,3), class = b)\n  ),\n  backend = \"cmdstanr\",\n  cores = 4,\n  file = \"haunted1\"\n)->\n  haunted1_mod\n```\n:::\n\n\nNow let's get the parameters and compare them to the true values that we created the simulation with.\n\n\n::: {.cell filename='true values'}\n\n```{.r .cell-code}\ntribble(\n  ~.variable, ~.value,\n  \"b_Intercept\", 0,\n  \"b_grandparent\", b_GC,\n  \"b_parent\", b_PC\n)->\n  true_param\n```\n:::\n\n::: {.cell filename='haunted params'}\n\n```{.r .cell-code}\nhaunted1_mod |> \n  gather_draws(\n    `b_.*`,\n    regex = T \n  ) ->\n  haunted1_params\n```\n:::\n\n::: {.cell crop='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\nhaunted1_params |> \n  ggplot(\n    aes(\n      .value,\n      .variable\n    )\n  ) +\n    geom_vline(xintercept = 0)+\n    stat_halfeye()+\n    geom_point(\n      data = true_param,\n      aes(color = \"true value\"),\n      size = 3\n    )+\n    scale_color_manual(\n      values = ptol_red,\n      name = NULL\n    )+\n    theme(\n      legend.position = \"top\"\n    )\n```\n\n::: {.cell-output-display}\n![Haunted parameters!](index_files/figure-html/fig-hanted-param-1.png){#fig-hanted-param width=576}\n:::\n:::\n\n\nAs far as things go, the model will make good predictions, because the statistical associations are correct, but the causal interpretation (\"Grandparents have a negative effect\") is wrong.\n\n\n::: {.cell filename='posterior predictive check'}\n\n```{.r .cell-code}\npp_check(haunted1_mod)\n```\n\n::: {.cell-output-display}\n![Haunted posterior predictive check](index_files/figure-html/fig-haunted-pp-1.png){#fig-haunted-pp width=576}\n:::\n:::\n\n\nIncluding the variable haunting the DAG ought to improve things, but in reality that assumes we *know* what it is, and have some *measure* of it.\n\n\n::: {.cell filename='Exorcised model'}\n\n```{.r .cell-code}\nbrm(\n  child ~ parent + grandparent + neighborhood,\n  data = haunted_sim,\n  prior = c(\n    prior(normal(0,3), class = b)\n  ),\n  backend = \"cmdstanr\",\n  cores = 4,\n  file = \"exorcised1\"\n)->\n  exorcised1_mod\n```\n:::\n\n::: {.cell filename='true params'}\n\n```{.r .cell-code}\ntribble(\n  ~.variable, ~.value,\n  \"b_Intercept\", 0,\n  \"b_grandparent\", b_GC,\n  \"b_parent\", b_PC,\n  \"b_neighborhood\", b_N\n)->\n  true_param\n```\n:::\n\n::: {.cell filename='exorcised params'}\n\n```{.r .cell-code}\nexorcised1_mod |> \n  gather_draws(\n    `b_.*`,\n    regex = T \n  ) ->\n  exorcised1_params\n```\n:::\n\n::: {.cell crop='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\nexorcised1_params |> \n  ggplot(\n    aes(\n      .value,\n      .variable\n    )\n  ) +\n    geom_vline(xintercept = 0)+\n    stat_halfeye()+\n    geom_point(\n      data = true_param,\n      aes(color = \"true value\"),\n      size = 3\n    )+\n    scale_color_manual(\n      values = ptol_red,\n      name = NULL\n    )+\n    theme(\n      legend.position = \"top\"\n    )\n```\n\n::: {.cell-output-display}\n![Exoricsed params](index_files/figure-html/fig-exorcised-1.png){#fig-exorcised width=576}\n:::\n:::\n\n\nI'm not sure why my posterior estimates are so much further off from McElreath's...\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}