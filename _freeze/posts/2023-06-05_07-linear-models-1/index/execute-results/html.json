{
  "hash": "2c247773ee5f04e656a9c61a42b726cb",
  "result": {
    "markdown": "---\ntitle: \"Linear Models: Part 1\"\ndate: 2023-06-05\norder: 08\n---\n\n\n::: callout-note\n## Listening\n\n<iframe style=\"border-radius:12px\" src=\"https://open.spotify.com/embed/track/7AlWVgCBCZtjYGayAqYLPH?utm_source=generator\" width=\"100%\" height=\"152\" frameBorder=\"0\" allowfullscreen allow=\"autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture\" loading=\"lazy\">\n\n</iframe>\n:::\n\n## Loading\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggdist)\nlibrary(here)\n\nsource(here(\"_defaults.R\"))\n```\n:::\n\n\n## Simulating a Galton Board\n\n> \"Suppose you and a thousand of your closest friends line up in the halfway line of a soccer field.\"\n\nOk, so the N is 1+1,000 (\"you and 1000 of your closest friends\"). Apparently a soccer field is 360 feet long, and an average stride length is something like 2.3 feet.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(360/2)/2.3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 78.26087\n```\n:::\n:::\n\n\nWe can get in 78 steps from the halfway line to the end of the field.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(500)\n\nexpand_grid(\n  person = 1:1001,\n  step = 1:78\n) |> \n  mutate(\n    flip = sample(\n      c(-1, 1), \n      size = n(), \n      replace = T\n    )\n  ) |> \n  mutate(\n    .by = person,\n    position = cumsum(flip)\n  ) ->\n  galton_board\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngalton_board |> \n  mutate(\n    .by = c(step, position),\n    n = n()\n  ) ->\n  galton_board\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngalton_board |> \n  ggplot(\n    aes(step, position)\n  )+\n    geom_line(\n      aes(group = person, color = n)\n    ) +\n  scale_x_reverse()+\n  khroma::scale_color_bilbao(\n      guide = \"none\"\n    )+  \n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=576}\n:::\n:::\n\n\nIt's hard to visualize well with the completely overlapping points. I'll plot histograms for very 10th step.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngalton_board |> \n  filter(step %in% seq(10, 70, by = 10)) |> \n  ggplot(aes(position, factor(step)))+\n    stat_histinterval(\n      breaks = breaks_fixed(width = 2),\n      aes(fill = after_stat(pdf))\n    )+\n    khroma::scale_fill_bilbao(\n      guide = \"none\"\n    )+\n    scale_y_discrete(\n      limits = factor(seq(70, 10, by = -10))\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=576}\n:::\n:::\n\n\n## Infinitesimal Galton Board\n\nSame as before, but now instead of flipping a coin for -1 and 1, values are sampled from $\\mathcal{U}(-1,1)$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpand_grid(\n  person = 1:1001,\n  step = 1:78\n) |> \n  mutate(\n    flip = runif(\n      n(),\n      -1,\n      1\n    )\n  ) |> \n  mutate(\n    .by = person,\n    position = cumsum(flip)\n  ) ->\n  inf_galton_board\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninf_galton_board |> \n  ggplot(aes(step, position))+\n    geom_line(\n      aes(group = person),\n      alpha = 0.05\n    )+\n  scale_x_reverse()+\n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=576}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninf_galton_board |> \n  filter(step %in% seq(10, 70, by = 10)) |> \n  ggplot(aes(position, factor(step)))+\n    stat_slabinterval(\n      aes(fill = after_stat(pdf)), \n      fill_type = \"gradient\"\n    )+\n    khroma::scale_fill_bilbao(\n      guide = \"none\"\n    )+\n    scale_y_discrete(\n      limits = factor(seq(70, 10, by = -10))\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=576}\n:::\n:::\n\n\nNice.\n\nI'm not 100% sure how to get a normal density estimate superimposed in that same plot. So I'll fake it instead.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninf_galton_board |> \n  filter(step %in% seq(10, 70, by = 10)) ->\n  ten_steps\n\nten_steps |> \n  summarise(                 # <1>\n    .by = step,              # <1>\n    mean = mean(position),   # <1>\n    sd = sd(position)        # <1>\n  ) |> \n  nest(\n    .by = step\n  ) |> \n  mutate(\n    dist = map(              # <2>\n      data,\n      ~tibble(\n        position = seq(-20, 20, length = 100),\n        dens = dnorm(\n          position, \n          mean = .x$mean, \n          sd = .x$sd\n        )\n      )\n    )\n  ) |> \n  unnest(dist) |> \n  mutate(                       # <3>\n    dens_norm = dens/max(dens)  # <3>\n  )->\n  distributions\n```\n:::\n\n\n1.  Calculating the distribution parameters for each step grouping.\n2.  Mapping over the distribution parameters to get density values in a tibble.\n3.  For plotting over the `stat_slab()` output, normalizing the density to max out at 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nten_steps |> \n  ggplot(aes(position))+\n    stat_slabinterval(\n      aes(fill = after_stat(pdf)), \n      fill_type = \"gradient\"\n    )+\n    geom_line(\n      data = distributions,\n      aes(y = dens_norm)\n    )+\n    khroma::scale_fill_bilbao(\n      guide = \"none\"\n    )+\n    facet_wrap(\n      ~step, labeller = label_both\n    )+\n    theme_no_y()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=576}\n:::\n:::\n\n\n### Comparing parameters\n\nFor my own interest, I wonder how much discrete sampling from -1, 1 vs the uniform distribution affects the $\\sigma$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngalton_board |> \n  summarise(\n    .by = step,\n    pos_sd = sd(position)\n  ) |> \n  mutate(\n    sampling = \"discrete\"\n  ) ->\n  galton_sd\n\ninf_galton_board |> \n  summarise(\n    .by = step,\n    pos_sd = sd(position)\n  ) |> \n  mutate(\n    sampling = \"uniform\"\n  )->\n  inf_galton_sd\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_rows(\n  galton_sd, \n  inf_galton_sd\n) |> \n  ggplot(aes(step, pos_sd))+\n    geom_line(\n      aes(color = sampling),\n      linewidth = 1\n    )+\n    expand_limits(y = 0)+\n    labs(\n      y = expression(sigma)\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=576}\n:::\n:::\n\n\nMessing around with a few obvious values of $x$, in $\\mathcal{U}(-x,x)$, I can't tell what would approximate the discrete sampling. 2 is too large, and 1.5 is too small. The answer is probably some horror like $\\frac{\\pi}{e}$.[^1]\n\n[^1]: Not literally $\\frac{\\pi}{e}$ though, cause that's too small at 1.156\n\n## Model Diagrams\n\nHere's the model described in the text.\n\n$$\ny_i \\sim \\mathcal{N}(\\mu_i, \\sigma)\n$$\n\n$$\n\\mu_i = \\beta x_i\n$$\n\n$$\n\\beta \\sim \\mathcal{N}(0, 10)\n$$\n\n$$\n\\sigma \\sim \\text{Exponential}(1)\n$$\n\nHe also defines a sampling distribution over $x_1$, but idk if that's right. Here's my attempt at converting that into a mermaid diagram.\n\n\n```{mermaid}\nflowchart RL\n  normal1[\"N(μᵢ, σ)\"] -->|\"~\"| y[\"yᵢ\"]\n  beta[\"β\"] --> mult1([\"×\"])\n  x[xᵢ] --> mult1\n  mult1 --> mu1[μᵢ]\n  mu1 --> normal1\n  \n  exp1[\"Exp(1)\"] --\"~\"--> sigma1[σ]\n  sigma1 --> normal1\n  \n  normal2[\"N(0,10)\"] --\"~\"--> beta\n```\n\n\nIt's ok. No quite a Kruschke diagram.\n\n### Another example.\n\nLet me try to write out the diagram for something like `y ~ x + (1|z)`.\n\n$$\ny \\sim(\\mu_i, \\sigma_0)\n$$\n\n$$\n\\mu_i = \\beta_0 + \\beta_1x_i + \\gamma_i\n$$\n\n$$\n\\beta_0 \\sim \\mathcal{N}(0,10)\n$$\n\n$$\n\\beta_2 \\sim \\mathcal{N}(0,2)\n$$\n\n$$\n\\gamma_i = \\Gamma_{z_i}\n$$\n\n$$\n\\Gamma_j \\sim \\mathcal{N}(0,\\sigma_1)\n$$\n\n$$\n\\sigma_0 \\sim \\text{Exponential}(1)\n$$\n\n$$\n\\sigma_1 \\sim \\text{Exponential}(1)\n$$\\\n\nGeeze, idk. That double subscript feels rough, and I don't know the convention for describing the random effects.\n\n\n```{mermaid}\nflowchart TD\n  normal1[\"N(μᵢ, σ₀)\"] --\"~\"--> y[yᵢ]\n  beta0[\"β₀\"] --> plus([\"+\"])\n  beta1[\"β₁\"] --> plus\n  gamma[\"γᵢ\"] --> plus\n  plus --> mu[\"μᵢ\"]\n  mu --> normal1\n  normal2[\"N(0,10)\"] --\"~\"--> beta0\n  normal3[\"N(0,2)\"] --\"~\"--> beta1\n  Gamma[\"Γ[zᵢ]\"] --> gamma\n  normal4[\"N(0, σ₁)\"] --\"~\"--> Gamma\n  exponent0[\"Exp(1)\"] --\"~\"--> sigma0[\"σ₀\"]\n  sigma0 --> normal1\n  exponent1[\"Exp(1)\"] --\"~\"--> sigma1[\"σ₁\"]\n  sigma1 --> normal4\n  \n```\n\n\nYeah, this is too tall. Will have to think about this. The Krushke style diagram is the most compressed version imo.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}