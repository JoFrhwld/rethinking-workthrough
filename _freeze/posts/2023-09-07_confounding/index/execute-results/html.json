{
  "hash": "bfd40e7f829531e0b9650822fe24ab22",
  "result": {
    "markdown": "---\ntitle: \"Where I do a lot of work and don't understand colliders an y better.\"\norder: 18\ndate: 2023-09-06\ntwitter-card: true\nopen-graph: true\n---\n\n\n::: callout-note\n## Listening\n\n<iframe style=\"border-radius:12px\" src=\"https://open.spotify.com/embed/track/1ASW01GI8BsvO36SsURwpp?utm_source=generator\" width=\"100%\" height=\"152\" frameBorder=\"0\" allowfullscreen allow=\"autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture\" loading=\"lazy\">\n\n</iframe>\n:::\n\n## Setup\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(tidyverse)\nlibrary(tidybayes)\nlibrary(brms)\nlibrary(gt)\nlibrary(gtsummary)\nlibrary(patchwork)\nlibrary(ggblend)\nlibrary(ggdensity)\nlibrary(ggforce)\nlibrary(marginaleffects)\nlibrary(dagitty)\nlibrary(ggdag)\nlibrary(khroma)\n\n\nsource(here::here(\"_defaults.r\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2023-9-7)\n```\n:::\n\n\n## Developing a sense for colliders\n\nFor me to really get a sense of how coliders work, I'm going to have to simulate a few different datasets, messing around with the parameters, and compare the outcomes. I won't do this full Bayesian for the sake of speed. As a reminder, here's the DAG. I'll specifically be messing around with the effect of `n` on `p` and `c`.\n\n\n::: {.cell crop='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\ndagify(\n  c ~ p + g + n,\n  p ~ g + n\n) |> \n  tidy_dagitty() ->\n  the_dag\n\nthe_dag |> \n  mutate(\n    from_n = ifelse(name == \"n\", ptol_red, \"black\")\n  ) |> \n  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +\n    geom_dag_point(\n      aes(\n        shape = name == \"c\"\n      )\n    )+\n    geom_dag_edges(\n      aes(\n        edge_color = from_n\n      )\n    )+\n    geom_dag_text()+\n    scale_color_manual(\n      values = c(\"grey60\", ptol_red)\n    )+\n    guides(\n      shape = \"none\",\n      color = \"none\"\n    )+\n    theme_dag()\n```\n\n::: {.cell-output-display}\n![DAG with a collider](index_files/figure-html/fig-orig-dag-1.png){#fig-orig-dag width=576}\n:::\n:::\n\n\nI refactored [the code from before](../2023-09-06_haunted-dag-3/index.qmd#simulating-the-haunted-dag) into a function:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"simulation function\"}\nsim_collider <- function(\n    n = 200,\n    # Grandparent on parent\n    b_GP = 1,\n    # Parent on Child\n    b_PC = b_GP,\n    # Grandparent on Child\n    b_GC = 0,\n    # neighborhood\n    b_N = 2){\n  \n  tibble(\n    grandparent = rnorm(n),\n    neighborhood = rbinom(\n      n, \n      size = 1, \n      prob = 0.5\n    ),\n    parent = rnorm(\n      n,\n      mean = b_GP * grandparent + \n        b_N * neighborhood\n    ),\n    child = rnorm(\n      n,\n      mean = b_GC * grandparent +\n        b_PC * parent + \n        b_N  * neighborhood\n    )\n  ) ->\n    haunted_sim\n  \n  return(haunted_sim)\n}\n```\n:::\n\n\nAnd I'll do a grid of 100 values from -11 to 11 for `b_N`.\n\n\n::: {.cell filename='simulation parameters'}\n\n```{.r .cell-code}\ntibble(\n  n = 200,\n  b_GP = 1,\n  b_PC = 1,\n  b_GC = 0,\n  b_N = rep(seq(-11, 11, length = 100), 10)\n) -> \n  sim_params\n```\n:::\n\n\nNow, with some tidyverse fanciness, I'll map the simulation function I wrote across each row to get simulation datasets.\n\n\n::: {.cell filename='Simulating the data with pmap'}\n\n```{.r .cell-code}\nsim_params |> \n  rowwise() |> \n  mutate(\n    data = pmap(\n      list(n, b_GP, b_PC, b_GC, b_N),\n      sim_collider\n    )\n  ) |> \n  ungroup()->\n  sim_data\n```\n:::\n\n\nThen, for each data set I'll fit\n\n```         \nlm(child ~ parent + grandparent)\n```\n\nand then get the parameters.\n\n\n::: {.cell filename='Fitting a model for each simulation'}\n\n```{.r .cell-code}\nsim_data |> \n  mutate(\n    model = map(\n      data, \n      ~lm(child ~ parent + grandparent, data = .x)\n    ),\n    params = map(model, broom::tidy)\n  ) |> \n  unnest(params) |> \n  select(\n    starts_with(\"b_\"),\n    term, \n    estimate\n  ) ->\n  model_params\n```\n:::\n\n::: {.cell crop='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\ntrue_params <- tibble(\n  term = c(\"(Intercept)\", \"grandparent\", \"parent\"),\n  estimate = c(0, 0, 1)\n)\n\nmodel_params |> \n  ggplot(\n    aes(\n      b_N,\n      estimate\n    )\n  )+\n  geom_hline(\n    data = true_params,\n    aes(\n      yintercept = estimate\n    ),\n    color = \"grey40\"\n  )+\n  stat_summary(\n    fun.y = mean,\n    geom = \"line\"\n  )+\n  facet_wrap(~term)+\n  labs(\n    caption = \"b_GC = 0; b_GP = 1; b_PC = 1\"\n  )\n```\n\n::: {.cell-output-display}\n![Collider effect](index_files/figure-html/fig-collider1-1.png){#fig-collider1 width=576}\n:::\n:::\n\n\nHuh. I guess I wasn't expecting an asymptotic relationship for the `grandparent` and `parent` effects? It looks like as `b_N` gets large, the collider confounding reaches some kind of min/max, which for `grandparent` is -1, and for `parent` is 1. I don't know if this value relates to either the effect of `b_GP` or `b_PC`, since both were set to 1? Maybe time for another grid search. I'll really max outt the `b_N` effect to get fully into the tail of the asymptote.\n\n\n::: {.cell filename='One big simulation'}\n\n```{.r .cell-code}\nexpand_grid(\n  n = 200,\n  b_GP = rep(-2:2, 10),\n  b_PC = rep(-2:2, 10),\n  b_GC = 0,\n  b_N = 50\n) |> \n  rowwise() |> \n  mutate(\n    data = pmap(\n      list(n, b_GP, b_PC, b_GC, b_N),\n      sim_collider\n    )\n  ) |> \n  ungroup() |> \n  mutate(\n    model = map(\n      data, \n      ~lm(child ~ parent + grandparent, data = .x)\n    ),\n    params = map(model, broom::tidy)\n  ) |> \n  unnest(params) |> \n  select(\n    starts_with(\"b_\"),\n    term, \n    estimate\n  ) ->\n  big_sim\n```\n:::\n\n::: {.cell crop='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\nbig_sim |> \n  filter(\n    term != \"(Intercept)\"\n  ) |> \n  ggplot(\n    aes(\n      b_GP,\n      estimate\n    )\n  )+\n    stat_summary(\n      fun.y = mean,\n      geom = \"line\"\n    )+\n    scale_x_continuous(\n      breaks = c(-2, 0, 2)\n    )+\n    scale_y_continuous(\n      breaks = c(-2, 0, 2)\n    )+\n    facet_grid(term~b_PC, labeller = label_both)+\n    theme(\n      aspect.ratio = 1,\n      strip.text.y  = element_text(size = 8)\n    )+\n    labs(\n      caption = \"b_GC = 0; b_N = 50\"\n    )\n```\n\n::: {.cell-output-display}\n![Collider effect](index_files/figure-html/fig-pgc-sim-1.png){#fig-pgc-sim width=576}\n:::\n:::\n\n\nHuh. The associations *look* straightforward, but I think I need an animation to get it.\n\n------------------------------------------------------------------------\n\nThis turned into a whole thing.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(gganimate)\nnframes = 100\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ncolor_value <- function(x, min.v = -2, max.v = 2, scale = color(\"berlin\")(100)){\n  prop = (x - min.v)/(max.v-min.v)\n  closest_idx = round(prop * (length(scale)-1))+1\n  return(scale[closest_idx])\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntibble(\n  name = \"p\",\n  to = \"c\",\n  true = 1,\n  est = true + 1,\n  id = seq(-2, 2, length = nframes),\n  col = color_value(true)\n) |> \n  bind_rows(\n    tibble(\n      name = \"g\",\n      to = \"c\",\n      true = 0,\n      est = seq(2, -2, length = nframes),\n      id = seq(-2, 2, length = nframes),\n      col = color_value(true)\n    )\n  ) |> \n  bind_rows(\n    tibble(\n      name = \"g\",\n      to = \"p\",\n      true = seq(-2, 2, length = nframes),\n      est = NA ,\n      id = seq(-2, 2, length = nframes),\n      col = color_value(true)\n    )\n  ) |> \n  bind_rows(\n    tribble(\n      ~name, ~to, ~true, ~est,\n     \"n\", \"c\",  NA,  NA,\n     \"n\", \"p\",  NA,  NA,\n     \"c\", NA, NA, NA\n    ) |> \n      mutate(\n        across(true:est, as.numeric),\n        col = \"#000000\"\n      ) |> \n      group_by(name, to, true, est, col) |> \n      reframe(\n        id = seq(-2, 2, length = nframes)\n      ) \n  )->\n  pc_true_anim\n\ntibble(\n  name = \"p\",\n  to = \"c\",\n  true = 1,\n  est = true + 1,\n  id = seq(-2, 2, length = nframes),\n  col = color_value(est)\n) |> \n  bind_rows(\n    tibble(\n      name = \"g\",\n      to = \"c\",\n      true = 0,\n      est = seq(2, -2, length = nframes),\n      id = seq(-2, 2, length = nframes),\n      col = color_value(est)\n    )\n  ) ->\n  pc_est_anim\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\npc_true_anim |> \n  left_join(the_dag |> as_tibble()) ->\n  true_dag\n\npc_est_anim |> \n  left_join(the_dag |> as_tibble()) ->\n  est_dag\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntrue_dag |> \n  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +\n    geom_dag_point(\n      color = \"grey\",\n    )+\n    geom_dag_text()+\n    geom_segment(\n      arrow = arrow(type = \"closed\", length = unit(0.2, \"cm\")),\n      linewidth = 1,\n      aes(\n        color = col\n      )\n    )+\n    geom_segment(\n      data = est_dag,\n      linetype = \"dashed\",\n      aes(\n        x = x+0.1, y = y+0.1, xend = xend+0.1, yend = yend+0.1,\n        color = col\n      ),\n      arrow = arrow(type = \"closed\", length = unit(0.2, \"cm\")),\n      linewidth = 1\n    )+\n    scale_color_identity()+\n    transition_time(\n      id\n    )+\n  labs(\n    title = \"b_GP: {round(frame_time, digits = 2)}\\nest_GC: {round(frame_time*-1, digits = 2)}\"\n  )+\n  theme_dag()->a\nanimate(a, rewind = T) |> \n  anim_save(\n    filename = \"dag_anim.gif\"\n  )\n```\n:::\n\n\n![Animated DAG](dag_anim.gif){#fig-dag-anim fig-align=\"center\" width=\"59%\"}\n\nSo, as the true effect of Grandparents on parents changes, the estimated direct effect on children is inversely proportional, and, for some reason, the direct effect of parents is just +1?\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}